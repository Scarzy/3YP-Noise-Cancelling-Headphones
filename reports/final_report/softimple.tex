\section{Software}
The algorithmic side of the system was implemented in the C programming language, due to the amount of control it provided and the fact that the available compilers required C.

\subsubsection{Ring Buffers}

Some data needed to be stored in the DSP for the algorithm to work, whether the correlation method or the LMS method.
There are a few ways to achieve this.
One option is an array.
This would give the advantage of a simple system, whereby the latest value is loaded into the array.
The issue then arises on how to determine the location in the array to load the value, and how to maintain a consistent amount of storage.
If there's no wrapping around at the end of the array, then one of two options are available.
Either the new value is entered at the beginning of the array, and all other values get shifted along.
This method is very heavy on resources as it requires all the values in the arrays to be moved for each new sample.
The alternative is that the amount of data available for each sample varies, dropping down to just a single sample at times during the analysis.
This latter method is basically unacceptable for this project, it would result in the algorithm being unable to respond at portions of the time.
Alternatively the option of wrapping round at the end of the array, this is the first step towards a ring buffer.
Wrapping around at the end of an array removes the need to shift all values along upon receiving a new sample, it also prevents varying available data sizes.
However it then introduces an issue of keeping track of the location in the array and how to deal with the wrap-around.
Multiple variables would have to be stored and whenever a piece of code works with the array it would have to keep track of the wrapping around, introducing a large margin for error in coding.
\\
\\
To eliminate this, a ring buffer struct was developed.
This allowed the required variables to be linked directly with the array being dealt with, and shifting through the array could now be done with a standard function that only required a single argument.
The result of using ring buffers was that the code became simpler to write and deal with, reducing room for error, however this came at a cost.
Using a simple array based method would have resulted in minimal computational effort in shifting through the array, with ring buffers more effort was required, slowing down the overall operation.
Thanks to the speed of the DSP the number of clock cycles this would cost was minimal, and as such ring buffers were used for the remainder of the project.
\\
\\
The use of ring buffers provided other advantages.
After implementing the different algorithms optimisation was required, and the ring buffers assisted with that greatly.
For example, when calculating the mean of the data in the buffer, it is known that the next sample in the buffer, regardless of position in the buffer, is the oldest sample.
Therefore, in order to determine the mean and additional variable could be stored holding the sum of the values in the buffer, and on a new sample the oldest sample can be subtracted, the new value added, and then a single division made.
As a result calculating the mean is reduced to a single addition, single subtraction, single division, and a single shift through the buffer, rather than an addition and shift for each value in the buffer, followed by a division.
This is a huge time saving, and as the number of clock cycles is heavily restricted a saving this large is a real advantage.

\subsubsection{Code Isolation}
In order to ease the writing and testing of the code, separate parts of the code were written in separate files, with minimal requirements from other files.
All the code that interfaced with external devices, such as the code relating to the codec communications, was especially separated out, with only functions
to get and send data used externally.
This gave the advantage that all the algorithmic code was cross platform, enabling it to be tested on normal computer systems.
Of course to test it on a normal computer system, the I/O calls and the codec interface were no longer valid, so had to be mimicked.
This mimicking was achieved through a minimalistic block of code which simply read from a file and wrote to the console.
\\
\\
This ability to test it cross platform proved especially useful when a ring buffer pointer was not being shifted through the buffer correctly, resulting in a memory leakage.
The DSP just followed its programming and continued, overflowing and overwriting program memory.
This resulted in unexpected crashes on both the DSP and its debugger, which just looked like the code had frozen.
When tested in a linux terminal, the memory overflow was detected and indicated as a segmentation fault with a complete stack trace, allowing the bug to be very easily traced.

\subsubsection{Self Written}
In this project none of the C code used was taken from an available library or provided by anyone not involved in this project.
Some of the matlab code written during the modelling used inbuilt functions to begin with, in order to produce proof of concept, however then was re-written to remove these external functions.
\\
\\
There were multiple advantages to writing all the code.
One of these was the advantage of using the desirable data structures, in particular the ring buffers.
While many libraries available deal with ranges of data, they generally expect arrays and do not provide the capability to deal with the ring buffers used in the rest of the project.
This would result in having to resort to the alternatives, resulting in serious losses to functionality.
\\
\\
Of course, no advantages come for free, and as such there were multiple disadvantages to this approach.
The most obvious one being that all the code had to be written and tested, whereas this would have been done extensively with any available libraries.
On top of this, libraries are available for the DSP which achieve a variety of functions, and have had the assembly code hand optimised by the manufacturer, Texas Instruments (TI).
These optimisations were lost, resulting in slightly slower code.
However many of these libraries were incompatible with the data structures used by the rest of the system, so the losses in optimisations here were made up for through optimisation in other ways, as previously discussed.

\subsection{Correlation}

After writing the code for the correlation algorithm, a problem was discovered.
The algorithm for cross-correlation requires the use of the mean in the calculation.
Whilst the mean could be calculated easily due to the 

\subsection{LMS}

